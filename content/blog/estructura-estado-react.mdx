---
title: Estructura de estado en React
description: Conoce las diferentes estrucuturas de estado en React y aprende a elegir la correcta para tu proyecto.
date: 2025-09-19
author: David Ruiz
---

Estructurar el estado correctamente en tu aplicaci√≥n de React puede hacer la diferencia entre tener un componente que sea f√°cil de modificar y `debugear` o tener un componente que sea un constante dolor de cabeza cuando se trabaja con √©l.

## üèóÔ∏è Principios para estructurar un estado.

El objetivo detr√°s de los siguientes principios es el de hacer de que el estado sea f√°cil de actualizar sin introducir errores.

1. Agrupar estados relacionados.
2. Evitar contradicciones en estado.
3. Evitar estados redundantes.
4. Evitar duplicaci√≥n en estado.
5. Evitar anidaci√≥n excesiva de estado.

## üëâ Agrupar estados redundantes

A veces te encontrar√°s con escenarios donde tienes que actualizar dos o m√°s estados al mismo tiempo, como por ejemplo cuando trabajas con coordenadas. Podr√≠as crear un estado por cada coordenada de esta forma:

```js
const [x, setX] = useState(0);
const [y, setY] = useState(0);
const [z, setZ] = useState(0);
```

o podr√≠as crear un estado que represente un objeto con todas las variables a actualizar:

```js
const [position, setPosition] = useState({x:0, y:0, z:0});
```

<Callout>
  Recuerda que cuando el estado es un objeto, no puedes actualizar √∫nicamente una propiedad. En vez de hacer esto  `setPosition({ x: 20 })` por que estar√≠a reemplazando el objeto inicial con tres propiedades por un nuevo objeto que s√≥lo tiene una. En este caso tienes que utlizar el operador `spread` (...) el mismo que hace una copia de las propiedades y reescribes la que quieres cambiar de esta forma: `setPosition({ ...position, x: 20 })`.
</Callout>

## üëâ Evitar contradicciones en estado.

Es importante que analices el valor que va a tener cada estado y si no interfieren entre ellos. Por ejemplo puedes tener una aplicaci√≥n con los siguientes estados:

```js
  const [isTyping, setIsTyping] = useState(false); // enviando
  const [isSending, setIsSending] = useState(false); // enviando
  const [isSent, setIsSent] = useState(false);       // enviado
```

Si analizamos un poco estos estados nos podemos dar cuenta de que el estado `isSent` (enviado) no podr√° ser verdadero a menos que `isSending` (enviando) est√© el falso. No se va a dar el caso en que ambos sean verdaderos.

Teniendo en cuenta esto, podr√≠amos decir que el c√≥digo anterior no tiene ning√∫n problema, pero es propenso a errores, ya que tenemos que estar pendientes de actualizar ambos estados correctamente y al mismo tiempo, y esto es algo que como desarrolladores nos podemos olvidar. 

En el siguiente c√≥digo ver√°s lo que tenemos que hacer cada vez que necesitemos actulizar el estado:

```js
  function handleSubmit(e){
    // L√≥gica para el envio
    setIsTyping(false);
    setIsSending(true);
    setIsSent(false);

    // Luego del envio se actualiza el √∫ltimo estado
    setIsTyping(false);
    setIsSending(false);
    setIsSent(true);
  }
```

Pero si en alg√∫n momento olvidas llamar a los tres m√©todos y s√≥lo llamas uno, vas a tener un estado "imposible" donde al menos dos estados estar√°n en verdadero. Entre m√°s complejo sea tu componente, m√°s dif√≠cil ser√° saber que est√° pansado.

En este caso se recomienda tener un solo estado que represente los tres estados anteriores:

```js
  const [status, setStatus] = useState('typing'); // 'typing' - 'sending' - 'send'
```

Este estado s√≥lo podr√° tener uno de estos tres valores: `typing`, `sending` o `send`. De esta forma evitas confundirte entre estados u olvidarte de actualizar alguno de ellos.

<Callout>
  Si deseas mejorar a√∫n.
</Callout>