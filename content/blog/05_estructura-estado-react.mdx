---
title: Estructura de estado en React
description: Conoce las diferentes estrucuturas de estado en React y aprende a elegir la correcta para tu proyecto.
date: 2025-07-12
author: David Ruiz
---

Estructurar el estado correctamente en tu aplicaci√≥n de React puede hacer la diferencia entre tener un componente que sea f√°cil de modificar y `debugear` o tener un componente que sea un constante dolor de cabeza cuando se trabaja con √©l.

## üèóÔ∏è Principios para estructurar un estado.

El objetivo detr√°s de los siguientes principios es el de hacer de que el estado sea f√°cil de actualizar sin introducir errores.

1. Agrupar estados relacionados.
2. Evitar contradicciones en estado.
3. Evitar estados redundantes.
4. Evitar duplicaci√≥n en estado.
5. Evitar anidaci√≥n excesiva de estado.

## üëâ Agrupar estados relacionados

A veces te encontrar√°s con escenarios donde tienes que actualizar dos o m√°s estados al mismo tiempo, como por ejemplo cuando trabajas con coordenadas. Podr√≠as crear un estado por cada coordenada de esta forma:

```js
const [x, setX] = useState(0);
const [y, setY] = useState(0);
const [z, setZ] = useState(0);
```

o podr√≠as crear un estado que represente un objeto con todas las variables a actualizar:

```js
const [position, setPosition] = useState({x:0, y:0, z:0});
```

<Callout>
  Recuerda que cuando el estado es un objeto, no puedes actualizar √∫nicamente una propiedad. En vez de hacer esto  `setPosition({ x: 20 })` por que estar√≠a reemplazando el objeto inicial con tres propiedades por un nuevo objeto que s√≥lo tiene una. En este caso tienes que utlizar el operador `spread` (...) el mismo que hace una copia de las propiedades y reescribes la que quieres cambiar de esta forma: `setPosition({ ...position, x: 20 })`.
</Callout>

## üëâ Evitar contradicciones en estado.

Es importante que analices el valor que va a tener cada estado y si no interfieren entre ellos. Por ejemplo puedes tener una aplicaci√≥n con los siguientes estados:

```js
  const [isTyping, setIsTyping] = useState(false); // enviando
  const [isSending, setIsSending] = useState(false); // enviando
  const [isSent, setIsSent] = useState(false);       // enviado
```

Si analizamos un poco estos estados nos podemos dar cuenta de que el estado `isSent` (enviado) no podr√° ser verdadero a menos que `isSending` (enviando) est√© el falso. No se va a dar el caso en que ambos sean verdaderos.

Teniendo en cuenta esto, podr√≠amos decir que el c√≥digo anterior no tiene ning√∫n problema, pero es propenso a errores, ya que tenemos que estar pendientes de actualizar ambos estados correctamente y al mismo tiempo, y esto es algo que como desarrolladores nos podemos olvidar. 

En el siguiente c√≥digo ver√°s lo que tenemos que hacer cada vez que necesitemos actulizar el estado:

```js
  function handleSubmit(e){
    // L√≥gica para el envio
    setIsTyping(false);
    setIsSending(true);
    setIsSent(false);

    // Luego del envio se actualiza el √∫ltimo estado
    setIsTyping(false);
    setIsSending(false);
    setIsSent(true);
  }
```

Pero si en alg√∫n momento olvidas llamar a los tres m√©todos y s√≥lo llamas uno, vas a tener un estado "imposible" donde al menos dos estados estar√°n en verdadero. Entre m√°s complejo sea tu componente, m√°s dif√≠cil ser√° saber que est√° pansado.

En este caso se recomienda tener un solo estado que represente los tres estados anteriores:

```js
  const [status, setStatus] = useState('typing'); // 'typing' - 'sending' - 'send'
```

Este estado s√≥lo podr√° tener uno de estos tres valores: `typing`, `sending` o `send`. De esta forma evitas confundirte entre estados u olvidarte de actualizar alguno de ellos.

### Usando Typescript

Se puede mejorar a√∫n m√°s el c√≥digo anterior usando Typescript. Con Typescript podemos usar `union types`, los mismos que permiten definir un string con valores espec√≠ficos. Es decir el c√≥digo anterior quedar√≠a de la siguiente forma:

```ts 
  type Status: 'typing', 'sending', 'send';
  const [status, setStatus] = useState<Status>('typing'); // 'typing' - 'sending' - 'send'
```

Con esto te aseguras tambi√©n que escribas mal alg√∫n estado omitiendo alguna letra por ejemplo.

## üëâ Evitar estados redundantes.

Un ejemplo simple para entender este principio es el siguiente:

```js
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');
```

Se podr√≠a pensar que necesitamos un estado para el nombre comppleto (`fullName`), pero en realidad este estado es redundante, ya que podemos obtener el nombre completo a partir de los otros dos estados (`firstName` y `lastName`).

Pero ya pensando en un ejemplo un poco m√°s complejo, analicemos el siguiente c√≥digo:

```js
  function ShoppingList({ items }) {
  const [query, setQuery] = useState("");
  const [filteredItems, setFilteredItems] = useState(items); // Estado redundante

  function handleSearch(e) {
    const value = e.target.value;
    setQuery(value);
    setFilteredItems(items.filter(item => item.includes(value))); // Estado redundante
  }

  return (
    <>
      <input value={query} onChange={handleSearch} />
      <ul>
        {filteredItems.map(item => <li key={item}>{item}</li>)}
      </ul>
    </>
  );
}
```

En este caso, el estado `filteredItems` es redundante, ya que podemos obtener los elementos filtrados a partir del estado `query` y la prop `items`.

Lo correcto ser√≠a lo siguiente:

```js
  function ShoppingList({ items }) {
  const [query, setQuery] = useState("");
  // const [filteredItems, setFilteredItems] = useState(items);

  function handleSearch(e) {
    const value = e.target.value;
    setQuery(value);
    // setFilteredItems(items.filter(item => item.includes(value)));
  }

  const filteredItems = items.filter(item => item.includes(query));

  return (
    <>
      <input value={query} onChange={handleSearch} />
      <ul>
        {filteredItems.map(item => <li key={item}>{item}</li>)}
      </ul>
    </>
  );
}
```